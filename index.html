<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Disc Throw — BLE</title>
<style>
  :root{ --bg:#f7f8fb; --card:#ffffff; --text:#111; --muted:#666; --accent:#2563eb; --ok:#16a34a; --warn:#d97706; --err:#dc2626; --border:#e5e7eb; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header{padding:10px 14px;border-bottom:1px solid var(--border);background:#fff;position:sticky;top:0;z-index:2}
  h1{margin:0;font-size:18px}
  .wrap{padding:12px;display:grid;gap:12px;grid-template-columns:1fr}
  @media (min-width:900px){ .wrap{grid-template-columns:420px 1fr;} }
  .card{background:var(--card);border:1px solid var(--border);border-radius:10px;box-shadow:0 1px 0 rgba(0,0,0,.03)}
  .card .pad{padding:14px}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .btn{appearance:none;border:1px solid var(--border);background:#fff;color:var(--text);padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;min-width:110px}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .btn.primary{background:var(--accent);color:#fff;border-color:var(--accent)}
  .btn.ok{background:var(--ok);color:#fff;border-color:var(--ok)}
  .btn.warn{background:var(--warn);color:#fff;border-color:var(--warn)}
  .btn.err{background:var(--err);color:#fff;border-color:var(--err)}
  .kvs{display:grid;grid-template-columns:repeat(2,minmax(120px,1fr));gap:8px}
  .kv{background:#fafafa;border:1px solid var(--border);border-radius:8px;padding:8px 10px}
  .kv .k{font-size:12px;color:var(--muted)}
  .kv .v{font-size:18px;font-weight:700}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  .log{height:260px;overflow:auto;background:#0b1020;color:#dbeafe;border-radius:8px;padding:10px;font-size:13px}
  .badge{display:inline-block;padding:3px 8px;border-radius:999px;border:1px solid var(--border);font-size:12px;color:var(--muted);background:#fff}
  .footer{padding:10px 14px;color:var(--muted);font-size:12px}
</style>
</head>
<body>
<header>
  <div class="row" style="justify-content:space-between;gap:8px">
    <h1>Disc Throw — BLE</h1>
    <div class="row">
      <span id="devName" class="badge">disconnected</span>
      <button id="btnConnect" class="btn primary">Connect</button>
    </div>
  </div>
</header>

<main class="wrap">
  <!-- Summary -->
  <section class="card">
    <div class="pad">
      <div class="row" style="justify-content:space-between;align-items:center">
        <h2 style="margin:0;font-size:16px">Summary</h2>
        <div class="row">
          <button id="btnRearm" class="btn ok" disabled>Rearm</button>
          <button id="btnSummary" class="btn" disabled>Summary</button>
          <button id="btnDump" class="btn" disabled>Dump</button>
          <button id="btnErase" class="btn err" disabled>Erase</button>
        </div>
      </div>
      <div style="height:8px"></div>
      <div class="kvs">
        <div class="kv"><div class="k">Apex</div><div class="v"><span id="apex">—</span> m</div></div>
        <div class="kv"><div class="k">Samples</div><div class="v" id="samples">—</div></div>
        <div class="kv"><div class="k">Peak accel</div><div class="v"><span id="apeak">—</span> g</div></div>
        <div class="kv"><div class="k">Peak gyro</div><div class="v"><span id="wpeak">—</span> dps</div></div>
        <div class="kv"><div class="k">Duration</div><div class="v"><span id="dur">—</span> ms</div></div>
        <div class="kv"><div class="k">ΔPressure</div><div class="v"><span id="pdrop">—</span> Pa</div></div>
      </div>
    </div>
  </section>

  <!-- Log -->
  <section class="card">
    <div class="pad">
      <div class="row" style="justify-content:space-between">
        <h2 style="margin:0;font-size:16px">Log</h2>
        <a id="btnSave" class="btn" download="throw.bin" style="display:none">Save dump</a>
      </div>
      <div style="height:8px"></div>
      <pre id="log" class="log"></pre>
    </div>
  </section>
</main>

<div class="footer" id="supportNote">
  Tip: use Chrome/Edge on desktop (HTTPS). iOS Safari doesn’t support Web Bluetooth.
</div>

<script>
(() => {
  // --- NUS UUIDs ---
  const NUS_SERVICE = '6e400001-b5a3-f393-e0a9-e50e24dcca9e';
  const NUS_RX      = '6e400002-b5a3-f393-e0a9-e50e24dcca9e'; // Write
  const NUS_TX      = '6e400003-b5a3-f393-e0a9-e50e24dcca9e'; // Notify

  // --- UI elements ---
  const logEl = document.getElementById('log');
  const devNameEl = document.getElementById('devName');
  const btnConnect = document.getElementById('btnConnect');
  const btnRearm = document.getElementById('btnRearm');
  const btnSummary = document.getElementById('btnSummary');
  const btnDump = document.getElementById('btnDump');
  const btnErase = document.getElementById('btnErase');
  const btnSave = document.getElementById('btnSave');

  const apexEl = document.getElementById('apex');
  const samplesEl = document.getElementById('samples');
  const apeakEl = document.getElementById('apeak');
  const wpeakEl = document.getElementById('wpeak');
  const durEl = document.getElementById('dur');
  const pdropEl = document.getElementById('pdrop');

  // Debug toggle
  const dbgBox = document.createElement('label');
  dbgBox.style.display = 'block';
  dbgBox.style.marginTop = '6px';
  dbgBox.innerHTML = '<input id="dbg" type="checkbox"> Debug chunks';
  logEl.parentElement.appendChild(dbgBox);
  const dbg = () => document.getElementById('dbg').checked;

  // BLE handles
  let device, server, rxChar, txChar;
  let connected = false;

  // Text buffer
  let textBuf = "";
  const td = new TextDecoder();

  // Dump state
  let awaitingHeader = false;
  let awaitingHeaderBuf = new Uint8Array(0);
  let awaitingHeaderTimeout = null;

  let dumping = false;
  let dumpExpected = 0;
  let dumpBuf = new Uint8Array(0);
  let dumpBytesSeen = 0;
  let lastProgressPct = -1;

  // NEW: detect '{"type":"dump_done"}' inside the binary stream
  const dumpDoneBytes = new TextEncoder().encode('{"type":"dump_done"}');
  function indexOfSubarray(hay, needle) {
    // Naive search; fine for small buffers
    outer: for (let i = 0; i <= hay.length - needle.length; i++) {
      for (let j = 0; j < needle.length; j++) if (hay[i + j] !== needle[j]) continue outer;
      return i;
    }
    return -1;
  }

  // NEW: inactivity timeout during dump
  let dumpSilenceTimer = null;
  function armDumpSilenceTimer() {
    clearTimeout(dumpSilenceTimer);
    dumpSilenceTimer = setTimeout(() => {
      if (dumping) {
        log(`Dump inactivity timeout — finalizing partial file (${dumpBytesSeen}/${dumpExpected}).`, '#fde68a');
        finishDump('timeout_partial');
      }
    }, 2000); // 2s without new data → finish partial
  }

  // UI helpers
  function log(msg, color) {
    const line = document.createElement('div');
    line.textContent = msg;
    if (color) line.style.color = color;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }
  function hexPreview(bytes, max=16) {
    const n = Math.min(bytes.length, max);
    let s = '';
    for (let i=0;i<n;i++) s += bytes[i].toString(16).padStart(2,'0') + ' ';
    return s.trim() + (bytes.length>n ? ' …' : '');
  }
  function setButtons(en) {
    btnRearm.disabled = btnSummary.disabled = btnDump.disabled = btnErase.disabled = !en;
  }
  function uiConnected(name) {
    connected = true;
    devNameEl.textContent = name || 'connected';
    devNameEl.style.borderColor = '#16a34a';
    devNameEl.style.color = '#16a34a';
    btnConnect.textContent = 'Disconnect';
    setButtons(true);
  }
  function uiDisconnected() {
    connected = false;
    devNameEl.textContent = 'disconnected';
    devNameEl.style.borderColor = '#e5e7eb';
    devNameEl.style.color = '#666';
    btnConnect.textContent = 'Connect';
    setButtons(false);
  }

  // Connect / disconnect
  async function connect() {
    try {
      log('Connect button clicked');
      const dev = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: [NUS_SERVICE]
      });
      device = dev;
      device.addEventListener('gattserverdisconnected', onDisconnected);

      log('Connecting to GATT…');
      server = await device.gatt.connect();

      const svc = await server.getPrimaryService(NUS_SERVICE).catch(err => {
        log('NUS service not found on this device. Check firmware UUIDs.', '#fca5a5');
        throw err;
      });

      rxChar = await svc.getCharacteristic(NUS_RX);
      txChar = await svc.getCharacteristic(NUS_TX);

      await txChar.startNotifications();
      txChar.addEventListener('characteristicvaluechanged', onTxNotify);

      uiConnected(device.name || 'DiscThrower');
      log('Connected to ' + (device.name || 'DiscThrower'));
      log('NUS service + RX/TX characteristics acquired');
    } catch (e) {
      log('Connect error: ' + e, '#fca5a5');
      try { if (device && device.gatt.connected) device.gatt.disconnect(); } catch {}
      uiDisconnected();
    }
  }
  async function disconnect() {
    log('Disconnect button clicked');
    try { if (device && device.gatt.connected) device.gatt.disconnect(); } catch {}
    uiDisconnected();
    log('Disconnected', '#fca5a5');
  }
  function onDisconnected() {
    log('Peripheral disconnected', '#fca5a5');
    uiDisconnected();
  }

  // Dump helpers
  function findDl01Header(bytes) {
    for (let i=0; i<=bytes.length-4; i++) {
      if (bytes[i]===0x44 && bytes[i+1]===0x4C && bytes[i+2]===0x30 && bytes[i+3]===0x31) return i;
    }
    return -1;
  }
  function startAwaitingHeader() {
    awaitingHeader = true;
    awaitingHeaderBuf = new Uint8Array(0);
    clearTimeout(awaitingHeaderTimeout);
    awaitingHeaderTimeout = setTimeout(() => {
      if (!awaitingHeader) return;
      awaitingHeader = false;
      log('Timeout while waiting for DL01 header — treating buffered data as text.', '#fde68a');
      try { textBuf += new TextDecoder().decode(awaitingHeaderBuf, {stream:true}); } catch {}
      awaitingHeaderBuf = new Uint8Array(0);
      setButtons(true); btnDump.textContent = 'Dump';
    }, 2000);
  }
  function enterDump(size, firstPayload) {
    awaitingHeader = false;
    clearTimeout(awaitingHeaderTimeout);
    dumpExpected = size >>> 0;
    dumping = true;
    dumpBuf = new Uint8Array(0);
    dumpBytesSeen = 0;
    lastProgressPct = -1;
    btnDump.textContent = 'Dumping…';
    setButtons(false);
    log(`DL01 header detected. Dump started: expecting ${dumpExpected} bytes`, '#fde68a');
    if (firstPayload && firstPayload.length) appendDumpData(firstPayload);
    armDumpSilenceTimer();
  }
  function appendDumpData(arr) {
    // While dumping, also check for {"type":"dump_done"} inside the chunk
    let chunk = arr;
    // Search marker in this chunk
    const idx = indexOfSubarray(chunk, dumpDoneBytes);
    if (idx !== -1) {
      // Everything before the marker is binary payload
      const pre = chunk.slice(0, idx);
      if (pre.length) appendDumpDataCore(pre);
      // Finish early (partial) because device signaled done
      finishDump('dump_done_marker_early');
      // Anything after the marker -> feed to text parser (likely ends with \n)
      const post = chunk.slice(idx + dumpDoneBytes.length);
      if (post.length) try { textBuf += td.decode(post, {stream:true}); } catch {}
      return;
    }
    // No marker → just append
    appendDumpDataCore(chunk);
  }
  function appendDumpDataCore(arr) {
    const old = dumpBuf;
    dumpBuf = new Uint8Array(old.length + arr.length);
    dumpBuf.set(old, 0);
    dumpBuf.set(arr, old.length);
    dumpBytesSeen += arr.length;

    // progress every 10%
    if (dumpExpected > 0) {
      const pct = Math.floor((dumpBytesSeen / dumpExpected) * 100);
      if (pct >= lastProgressPct + 10 || pct === 100) {
        lastProgressPct = pct;
        log(`Dump progress: ${dumpBytesSeen}/${dumpExpected} bytes (${pct}%)`, '#a7f3d0');
      }
    }
    armDumpSilenceTimer();
    // Complete if we hit expected size
    if (dumpBuf.length >= dumpExpected) {
      const extra = dumpBuf.length - dumpExpected;
      if (extra > 0) {
        const tail = dumpBuf.slice(dumpExpected);
        dumpBuf = dumpBuf.slice(0, dumpExpected);
        finishDump('bytes_complete_with_tail');
        try { textBuf += td.decode(tail, {stream:true}); } catch {}
      } else {
        finishDump('bytes_complete_exact');
      }
    }
  }
  function finishDump(reason="bytes_complete") {
    clearTimeout(dumpSilenceTimer);
    const finishedBytes = dumpBuf.length;
    const expect = dumpExpected;
    dumping = false;
    const blob = new Blob([dumpBuf], {type:'application/octet-stream'});
    const url = URL.createObjectURL(blob);
    btnSave.href = url;
    btnSave.style.display = 'inline-block';
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    btnSave.download = `throw_${ts}.bin`;
    btnDump.textContent = 'Dump';
    setButtons(true);
    if (expect && finishedBytes < expect) {
      log(`Dump finished early (${finishedBytes}/${expect}) [reason=${reason}] — saved partial file.`, '#fde68a');
    } else {
      log(`Dump finished (${finishedBytes}/${expect}) [reason=${reason}]. Tap "Save dump".`, '#86efac');
    }
  }

  // JSON helper
  function handleParsedJson(obj, rawLine) {
    if (obj && obj.type === 'summary') {
      apexEl.textContent    = Number.isFinite(obj.apex_m)     ? obj.apex_m.toFixed(2)   : '—';
      samplesEl.textContent = obj.samples ?? '—';
      apeakEl.textContent   = Number.isFinite(obj.a_peak_g)   ? obj.a_peak_g.toFixed(3) : '—';
      wpeakEl.textContent   = Number.isFinite(obj.w_peak_dps) ? obj.w_peak_dps.toFixed(1) : '—';
      durEl.textContent     = (obj.duration_ms ?? '—');
      pdropEl.textContent   = Number.isFinite(obj.p_drop_Pa)  ? obj.p_drop_Pa.toFixed(1) : '—';
      log('Summary parsed: ' + rawLine, '#93c5fd');
      return;
    }
    if (obj && obj.type === 'dump_done') {
      // If this arrives in text-mode after we already finalized early, just note it
      log('Dump done message received from device.', '#bbf7d0');
      if (dumping) finishDump('dump_done_message');
      return;
    }
    log(rawLine, '#cbd5e1');
  }

  // Notifications
  function onTxNotify(e) {
    const dv = e.target.value;
    const v  = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);

    if (dbg()) log(`[notify] len=${v.length} hex=${hexPreview(v)}`, '#94a3b8');

    // Waiting for header?
    if (awaitingHeader) {
      const maxBuf = 2048;
      let tmp = new Uint8Array(awaitingHeaderBuf.length + v.length);
      tmp.set(awaitingHeaderBuf, 0); tmp.set(v, awaitingHeaderBuf.length);
      if (tmp.length > maxBuf) tmp = tmp.slice(tmp.length - maxBuf);
      awaitingHeaderBuf = tmp;

      const idx = findDl01Header(awaitingHeaderBuf);
      if (idx !== -1 && awaitingHeaderBuf.length >= idx + 8) {
        const off = idx + 4;
        const size = awaitingHeaderBuf[off] | (awaitingHeaderBuf[off+1]<<8) | (awaitingHeaderBuf[off+2]<<16) | (awaitingHeaderBuf[off+3]<<24);
        const rem = awaitingHeaderBuf.slice(idx + 8);
        enterDump(size, rem);
        awaitingHeaderBuf = new Uint8Array(0);
      }
      return;
    }

    // Dumping?
    if (dumping) {
      appendDumpData(v);
      return;
    }

    // Normal text
    try { textBuf += td.decode(v, {stream:true}); } catch {}
    let pos;
    while ((pos = textBuf.indexOf('\n')) !== -1) {
      const line = textBuf.slice(0, pos).trim();
      textBuf = textBuf.slice(pos+1);
      if (!line) continue;
      if (line.startsWith('{') && line.endsWith('}')) {
        try { handleParsedJson(JSON.parse(line), line); continue; } catch {}
      }
      log(line);
    }
  }

  // Send helper
  async function sendCmd(s) {
    if (!rxChar) { log(`Cannot send "${s}": RX characteristic not ready`, '#fca5a5'); return; }
    const enc = new TextEncoder();
    const data = enc.encode(s + "\n");
    const step = 180;
    log(`Sending "${s}" (${data.length}B)…`);
    for (let i=0;i<data.length;i+=step) {
      await rxChar.writeValueWithoutResponse(data.slice(i, i+step));
      await new Promise(r=>setTimeout(r, 8));
    }
    log(`"${s}" sent; awaiting response…`, '#c7d2fe');
  }

  // UI bindings
  btnConnect.addEventListener('click', async()=>{ if (!connected) await connect(); else await disconnect(); });
  btnRearm.addEventListener('click', ()=>{ log('Rearm button clicked'); cancelDumpModes(); sendCmd('REARM'); });
  btnSummary.addEventListener('click', ()=>{ log('Summary button clicked'); cancelDumpModes(); sendCmd('SUMMARY'); });
  btnDump.addEventListener('click', ()=>{
    log('Dump button clicked');
    btnSave.style.display = 'none';
    dumpBuf = new Uint8Array(0); dumpExpected = 0; dumpBytesSeen = 0; lastProgressPct = -1;
    startAwaitingHeader();
    btnDump.textContent = 'Waiting header…';
    setButtons(false);
    log('DUMP sent (waiting for DL01 header)…');
    sendCmd('DUMP');
  });
  btnErase.addEventListener('click', ()=>{ log('Erase button clicked'); cancelDumpModes(); sendCmd('ERASE'); });

  function cancelDumpModes(){
    awaitingHeader = false; awaitingHeaderBuf = new Uint8Array(0);
    clearTimeout(awaitingHeaderTimeout);
    clearTimeout(dumpSilenceTimer);
    dumping = false;
    btnDump.textContent = 'Dump';
    setButtons(true);
  }

  // Environment note
  if (!('bluetooth' in navigator)) {
    document.getElementById('supportNote').innerHTML =
      'This browser does not expose Web Bluetooth. Use Chrome/Edge on desktop or Android.';
    btnConnect.disabled = true;
    log('Web Bluetooth not supported in this browser.', '#fca5a5');
  }
})();
</script>
</body>
</html>
